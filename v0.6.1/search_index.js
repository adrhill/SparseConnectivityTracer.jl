var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"CurrentModule = Main\nCollapsedDocStrings = true","category":"page"},{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api/#ADTypes-Interface","page":"API Reference","title":"ADTypes Interface","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer uses ADTypes.jl's interface for sparsity detection. In fact, the functions jacobian_sparsity and hessian_sparsity are re-exported from ADTypes.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"To compute global sparsity patterns of f(x) over the entire input domain x, use","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"TracerSparsityDetector","category":"page"},{"location":"api/#SparseConnectivityTracer.TracerSparsityDetector","page":"API Reference","title":"SparseConnectivityTracer.TracerSparsityDetector","text":"TracerSparsityDetector <: ADTypes.AbstractSparsityDetector\n\nSingleton struct for integration with the sparsity detection framework of ADTypes.jl.\n\nComputes global sparsity patterns over the entire input domain. For local sparsity patterns at a specific input point, use TracerLocalSparsityDetector.\n\nExample\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> ADTypes.jacobian_sparsity(diff, rand(4), TracerSparsityDetector())\n3×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 6 stored entries:\n 1  1  ⋅  ⋅\n ⋅  1  1  ⋅\n ⋅  ⋅  1  1\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> f(x) = x[1] + x[2]*x[3] + 1/x[4];\n\njulia> hessian_sparsity(f, rand(4), TracerSparsityDetector())\n4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 3 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"To compute local sparsity patterns of f(x) at a specific input x, use","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"TracerLocalSparsityDetector","category":"page"},{"location":"api/#SparseConnectivityTracer.TracerLocalSparsityDetector","page":"API Reference","title":"SparseConnectivityTracer.TracerLocalSparsityDetector","text":"TracerLocalSparsityDetector <: ADTypes.AbstractSparsityDetector\n\nSingleton struct for integration with the sparsity detection framework of ADTypes.jl.\n\nComputes local sparsity patterns at an input point x. For global sparsity patterns, use TracerSparsityDetector.\n\nExample\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> f(x) = x[1] > x[2] ? x[1:3] : x[2:4];\n\njulia> jacobian_sparsity(f, [1.0, 2.0, 3.0, 4.0], TracerLocalSparsityDetector())\n3×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 3 stored entries:\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1\n\njulia> jacobian_sparsity(f, [2.0, 1.0, 3.0, 4.0], TracerLocalSparsityDetector())\n3×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 3 stored entries:\n 1  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n\njulia> using ADTypes, SparseConnectivityTracer\n\njulia> f(x) = x[1] + max(x[2], x[3]) * x[3] + 1/x[4];\n\njulia> hessian_sparsity(f, [1.0, 2.0, 3.0, 4.0], TracerLocalSparsityDetector())\n4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 2 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  1\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API Reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"warning: Warning\nInternals may change without warning in a future release of SparseConnectivityTracer.","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer works by pushing Real number types called tracers through generic functions. Currently, two tracer types are provided:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer.GradientTracer\nSparseConnectivityTracer.HessianTracer","category":"page"},{"location":"api/#SparseConnectivityTracer.GradientTracer","page":"API Reference","title":"SparseConnectivityTracer.GradientTracer","text":"struct GradientTracer{P<:SparseConnectivityTracer.AbstractGradientPattern} <: SparseConnectivityTracer.AbstractTracer{P<:SparseConnectivityTracer.AbstractGradientPattern}\n\nReal number type keeping track of non-zero gradient entries.\n\nFields\n\npattern::SparseConnectivityTracer.AbstractGradientPattern: Sparse representation of non-zero entries in the gradient.\nisempty::Bool: Indicator whether gradient in tracer contains only zeros.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseConnectivityTracer.HessianTracer","page":"API Reference","title":"SparseConnectivityTracer.HessianTracer","text":"struct HessianTracer{P<:SparseConnectivityTracer.AbstractHessianPattern} <: SparseConnectivityTracer.AbstractTracer{P<:SparseConnectivityTracer.AbstractHessianPattern}\n\nReal number type keeping track of non-zero gradient and Hessian entries.\n\nFields\n\npattern::SparseConnectivityTracer.AbstractHessianPattern: Sparse representation of non-zero entries in the gradient and the Hessian.\nisempty::Bool: Indicator whether gradient and Hessian in tracer both contain only zeros.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API Reference","title":"API Reference","text":"These can be used alone or inside of the dual number type Dual, which keeps track of the primal computation and allows tracing through comparisons and control flow:","category":"page"},{"location":"api/","page":"API Reference","title":"API Reference","text":"SparseConnectivityTracer.Dual","category":"page"},{"location":"api/#SparseConnectivityTracer.Dual","page":"API Reference","title":"SparseConnectivityTracer.Dual","text":"struct Dual{P<:Real, T<:SparseConnectivityTracer.AbstractTracer} <: Real\n\nDual Real number type keeping track of the results of a primal computation as well as a tracer.\n\nFields\n\nprimal::Real\ntracer::SparseConnectivityTracer.AbstractTracer\n\n\n\n\n\n","category":"type"},{"location":"#SparseConnectivityTracer.jl","page":"Home","title":"SparseConnectivityTracer.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":" \nDocumentation (Image: Stable) (Image: Dev)\nBuild Status (Image: Build Status) (Image: Coverage) (Image: Aqua) (Image: JET)\nCode Style (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)\nCitation (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast Jacobian and Hessian sparsity detection via operator-overloading.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, open the Julia REPL and run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]add SparseConnectivityTracer","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#Jacobian","page":"Home","title":"Jacobian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For functions y = f(x) and f!(y, x), the sparsity pattern of the Jacobian can be obtained by computing a single forward-pass through the function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer\n\njulia> detector = TracerSparsityDetector();\n\njulia> x = rand(3);\n\njulia> f(x) = [x[1]^2, 2 * x[1] * x[2]^2, sin(x[3])];\n\njulia> jacobian_sparsity(f, x, detector)\n3×3 SparseArrays.SparseMatrixCSC{Bool, Int64} with 4 stored entries:\n 1  ⋅  ⋅\n 1  1  ⋅\n ⋅  ⋅  1","category":"page"},{"location":"","page":"Home","title":"Home","text":"As a larger example, let's compute the sparsity pattern from a convolutional layer from Flux.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer, Flux\n\njulia> detector = TracerSparsityDetector();\n\njulia> x = rand(28, 28, 3, 1);\n\njulia> layer = Conv((3, 3), 3 => 2);\n\njulia> jacobian_sparsity(layer, x, detector)\n1352×2352 SparseArrays.SparseMatrixCSC{Bool, Int64} with 36504 stored entries:\n⎡⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠻⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠙⢿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠙⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⣀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣷⣄⠀⎥\n⎢⢤⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠛⢦⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠳⣤⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠓⎥\n⎢⠀⠙⢿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠉⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⣄⠀⠀⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣷⣄⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣦⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⢿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠻⣷⣄⎦","category":"page"},{"location":"","page":"Home","title":"Home","text":"The type of index set S that is internally used to keep track of connectivity can be specified via jacobian_sparsity(f, x, S), defaulting to BitSet.  For high-dimensional functions, Set{Int64} can be more efficient .","category":"page"},{"location":"#Hessian","page":"Home","title":"Hessian","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For scalar functions y = f(x), the sparsity pattern of the Hessian of f can be obtained by computing a single forward-pass through f:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = rand(5);\n\njulia> f(x) = x[1] + x[2]*x[3] + 1/x[4] + 1*x[5];\n\njulia> hessian_sparsity(f, x, detector)\n5×5 SparseArrays.SparseMatrixCSC{Bool, Int64} with 3 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  ⋅\n\njulia> g(x) = f(x) + x[2]^x[5];\n\njulia> hessian_sparsity(g, x, detector)\n5×5 SparseArrays.SparseMatrixCSC{Bool, Int64} with 7 stored entries:\n ⋅  ⋅  ⋅  ⋅  ⋅\n ⋅  1  1  ⋅  1\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  1  ⋅  ⋅  1","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more detailled examples, take a look at the documentation.","category":"page"},{"location":"#Local-tracing","page":"Home","title":"Local tracing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TracerSparsityDetector returns conservative sparsity patterns over the entire input domain of x.  It is not compatible with functions that require information about the primal values of a computation (e.g. iszero, >, ==).","category":"page"},{"location":"","page":"Home","title":"Home","text":"To compute a less conservative sparsity pattern at an input point x, use TracerLocalSparsityDetector instead. Note that patterns computed with TracerLocalSparsityDetector depend on the input x:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using SparseConnectivityTracer\n\njulia> detector = TracerLocalSparsityDetector();\n\njulia> f(x) = ifelse(x[2] < x[3], x[1] ^ x[2], x[3] * x[4]);\n\njulia> hessian_sparsity(f, [1 2 3 4], detector)\n4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 4 stored entries:\n 1  1  ⋅  ⋅\n 1  1  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n\njulia> hessian_sparsity(f, [1 3 2 4], detector)\n4×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 2 stored entries:\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  ⋅\n ⋅  ⋅  ⋅  1\n ⋅  ⋅  1  ⋅","category":"page"},{"location":"#ADTypes.jl-compatibility","page":"Home","title":"ADTypes.jl compatibility","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseConnectivityTracer uses ADTypes.jl's interface for sparsity detection, making it compatible with DifferentiationInterface.jl's sparse automatic differentiation functionality.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In fact, the functions jacobian_sparsity and hessian_sparsity are re-exported from ADTypes.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseDiffTools.jl: automatic sparsity detection via Symbolics.jl and Cassette.jl\nSparsityTracing.jl: automatic Jacobian sparsity detection using an algorithm based on SparsLinC by Bischof et al. (1996)","category":"page"}]
}
