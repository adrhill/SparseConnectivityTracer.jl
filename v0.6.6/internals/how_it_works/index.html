<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How SparseConnectivityTracer works · SparseConnectivityTracer.jl</title><meta name="title" content="How SparseConnectivityTracer works · SparseConnectivityTracer.jl"/><meta property="og:title" content="How SparseConnectivityTracer works · SparseConnectivityTracer.jl"/><meta property="twitter:title" content="How SparseConnectivityTracer works · SparseConnectivityTracer.jl"/><meta name="description" content="Documentation for SparseConnectivityTracer.jl."/><meta property="og:description" content="Documentation for SparseConnectivityTracer.jl."/><meta property="twitter:description" content="Documentation for SparseConnectivityTracer.jl."/><meta property="og:url" content="https://adrhill.github.io/SparseConnectivityTracer.jl/internals/how_it_works/"/><meta property="twitter:url" content="https://adrhill.github.io/SparseConnectivityTracer.jl/internals/how_it_works/"/><link rel="canonical" href="https://adrhill.github.io/SparseConnectivityTracer.jl/internals/how_it_works/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SparseConnectivityTracer.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><span class="tocitem">User Documentation</span><ul><li><a class="tocitem" href="../../user/global_vs_local/">Global vs. Local Sparsity</a></li><li><a class="tocitem" href="../../user/limitations/">Limitations</a></li><li><a class="tocitem" href="../../user/api/">API Reference</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li class="is-active"><a class="tocitem" href>How SparseConnectivityTracer works</a><ul class="internal"><li><a class="tocitem" href="#Tracers-are-scalars"><span>Tracers are scalars</span></a></li><li><a class="tocitem" href="#Index-sets"><span>Index sets</span></a></li><li><a class="tocitem" href="#Motivating-example"><span>Motivating example</span></a></li><li><a class="tocitem" href="#Toy-implementation"><span>Toy implementation</span></a></li><li><a class="tocitem" href="#Tracing-Jacobians"><span>Tracing Jacobians</span></a></li><li><a class="tocitem" href="#Tracing-Hessians"><span>Tracing Hessians</span></a></li></ul></li><li><a class="tocitem" href="../adding_overloads/">Adding Overloads</a></li><li><a class="tocitem" href="../api/">Internals Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li class="is-active"><a href>How SparseConnectivityTracer works</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How SparseConnectivityTracer works</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/adrhill/SparseConnectivityTracer.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/adrhill/SparseConnectivityTracer.jl/blob/main/docs/src/internals/how_it_works.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="how-sct-works"><a class="docs-heading-anchor" href="#how-sct-works">How SparseConnectivityTracer works</a><a id="how-sct-works-1"></a><a class="docs-heading-anchor-permalink" href="#how-sct-works" title="Permalink"></a></h1><div class="admonition is-danger"><header class="admonition-header">Internals may change</header><div class="admonition-body"><p>The developer documentation might refer to internals which can change without warning in a future release of SparseConnectivityTracer. Only functionality that is exported or part of the <a href="../../user/api/#api">user documentation</a> adheres to semantic versioning.</p></div></div><h2 id="Tracers-are-scalars"><a class="docs-heading-anchor" href="#Tracers-are-scalars">Tracers are scalars</a><a id="Tracers-are-scalars-1"></a><a class="docs-heading-anchor-permalink" href="#Tracers-are-scalars" title="Permalink"></a></h2><p>SparseConnectivityTracer (SCT) works by pushing <code>Real</code> number types called tracers through generic functions using operator overloading. Currently, two tracer types are provided:</p><ul><li><a href="../api/#SparseConnectivityTracer.GradientTracer"><code>GradientTracer</code></a>: used for Jacobian sparsity patterns</li><li><a href="../api/#SparseConnectivityTracer.HessianTracer"><code>HessianTracer</code></a>: used for Hessian sparsity patterns</li></ul><p>When used alone, these tracers compute <a href="../../user/api/#SparseConnectivityTracer.TracerSparsityDetector"><strong>global</strong> sparsity patterns</a>. Alternatively, these can be used inside of a dual number type <a href="../api/#SparseConnectivityTracer.Dual"><code>Dual</code></a>,  which keeps track of the primal computation and allows tracing through comparisons and control flow. This is how <a href="../../user/api/#SparseConnectivityTracer.TracerLocalSparsityDetector"><strong>local</strong> sparsity patterns</a> are computed.</p><div class="admonition is-success"><header class="admonition-header">Tip: View SparseConnectivityTracer as binary ForwardDiff</header><div class="admonition-body"><p>SparseConnectivityTracer&#39;s <code>Dual{T, GradientTracer}</code> can be thought of as a binary version of <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff</a>&#39;s own <code>Dual</code> number type.  This is a good mental model for SparseConnectivityTracer if you are familiar with ForwardDiff and its limitations.</p></div></div><h2 id="Index-sets"><a class="docs-heading-anchor" href="#Index-sets">Index sets</a><a id="Index-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Index-sets" title="Permalink"></a></h2><p>Let&#39;s take a look at a scalar function <span>$f: \mathbb{R}^n \rightarrow \mathbb{R}$</span>. For a given input <span>$\mathbf{x} \in \mathbb{R}^n$</span>,  the gradient of <span>$f$</span> is defined as <span>$\left(\nabla f(\mathbf{x})\right)_{i} = \frac{\partial f}{\partial x_i}$</span>  and the Hessian as <span>$\left(\nabla^2 f(\mathbf{x})\right)_{i,j} = \frac{\partial^2 f}{\partial x_i \partial x_j}$</span>. </p><p>Sparsity patterns correspond to the mask of non-zero values in the gradient and Hessian. Instead of saving the values of individual partial derivatives, they can efficiently be represented by the set of indices corresponding to non-zero values:</p><ul><li>Gradient patterns are represented by sets of indices <span>$\left\{i \;\big|\; \frac{\partial f}{\partial x_i} \neq 0\right\}$</span></li><li>Hessian patterns are represented by sets of index tuples <span>$\left\{(i, j) \;\Big|\; \frac{\partial^2 f}{\partial x_i \partial x_j} \neq 0\right\}$</span></li></ul><div class="admonition is-warning"><header class="admonition-header">Global vs. Local</header><div class="admonition-body"><p>As shown in the page <a href="../../user/global_vs_local/#global-vs-local"><em>&quot;Global vs. Local&quot;</em></a>, global sparsity patterns are the index sets over all <span>$\mathbf{x}\in\mathbb{R}^n$</span>, whereas local patterns are the index sets for a given point <span>$\mathbf{x}$</span>. For a given function <span>$f$</span>, global sparsity patterns are therefore always supersets of local sparsity patterns  and more &quot;conservative&quot; in the sense that they are less sparse. </p></div></div><h2 id="Motivating-example"><a class="docs-heading-anchor" href="#Motivating-example">Motivating example</a><a id="Motivating-example-1"></a><a class="docs-heading-anchor-permalink" href="#Motivating-example" title="Permalink"></a></h2><p>Let&#39;s take a look at the computational graph of the equation <span>$f(\mathbf{x}) = x_1 + x_2x_3 + \text{sgn}(x_4)$</span>, where <span>$\text{sgn}$</span> is the <a href="https://en.wikipedia.org/wiki/Sign_function">sign function</a>:</p><div class="mermaid">flowchart LR
    subgraph Inputs
    X1[&quot;$$x_1$$&quot;]
    X2[&quot;$$x_2$$&quot;]
    X3[&quot;$$x_3$$&quot;]
    X4[&quot;$$x_4$$&quot;]
    end

    PLUS((+))
    TIMES((*))
    SIGN((sgn))
    PLUS2((+))

    X1 --&gt; |&quot;{1}&quot;| PLUS
    X2 --&gt; |&quot;{2}&quot;| TIMES
    X3 --&gt; |&quot;{3}&quot;| TIMES
    X4 --&gt; |&quot;{4}&quot;| SIGN
    TIMES  --&gt; |&quot;{2,3}&quot;| PLUS
    PLUS --&gt; |&quot;{1,2,3}&quot;| PLUS2
    SIGN --&gt; |&quot;{}&quot;| PLUS2

    PLUS2 --&gt; |&quot;{1,2,3}&quot;| RES[&quot;$$y=f(x)$$&quot;]</div><p>To obtain a sparsity pattern, each scalar input <span>$x_i$</span> gets seeded with a corresponding singleton index set <span>$\{i\}$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  Since addition and multiplication have non-zero derivatives with respect to both of their inputs,  their outputs accumulate and propagate the index sets of their inputs (annotated on the edges of the graph above). The sign function has zero derivatives for any input value. It therefore doesn&#39;t propagate the index set <span>${4}$</span> corresponding to the input <span>$x_4$</span>. Instead, it returns an empty set.</p><p>The resulting <strong>global</strong> gradient sparsity pattern <span>$\left(\nabla f(\mathbf{x})\right)_{i} \neq 0$</span> for <span>$i$</span> in <span>$\{1, 2, 3\}$</span> matches the analytical gradient</p><p class="math-container">\[\nabla f(\mathbf{x}) = \begin{bmatrix}
    \frac{\partial f}{\partial x_1} \\
    \frac{\partial f}{\partial x_2} \\
    \frac{\partial f}{\partial x_3} \\
    \frac{\partial f}{\partial x_4}
\end{bmatrix}
=
\begin{bmatrix}
    1 \\
    x_3 \\
    x_2 \\
    0
\end{bmatrix} \quad .\]</p><div class="admonition is-success"><header class="admonition-header">From Global to Local</header><div class="admonition-body"><p>Note that the <strong>local</strong> sparsity pattern could be more sparse in case <span>$x_2$</span> and/or <span>$x_3$</span> are zero. Computing such local sparsity patterns requires <a href="../api/#SparseConnectivityTracer.Dual"><code>Dual</code></a> numbers with information about the primal computation.  These are used to evaluate the <strong>local</strong> differentiability of operations like multiplication.</p></div></div><h2 id="Toy-implementation"><a class="docs-heading-anchor" href="#Toy-implementation">Toy implementation</a><a id="Toy-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Toy-implementation" title="Permalink"></a></h2><p>As mentioned above, SCT uses operator overloading to keep track of index sets. Let&#39;s start by implementing our own <code>MyGradientTracer</code> type:</p><pre><code class="language-julia hljs">struct MyGradientTracer
    indexset::Set
end</code></pre><p>We can now overload operators from Julia Base using our type:</p><pre><code class="language-julia hljs">import Base: +, *, sign

Base.:+(a::MyGradientTracer, b::MyGradientTracer) = MyGradientTracer(union(a.indexset, b.indexset))
Base.:*(a::MyGradientTracer, b::MyGradientTracer) = MyGradientTracer(union(a.indexset, b.indexset))
Base.sign(x::MyGradientTracer) = MyGradientTracer(Set()) # return empty index set</code></pre><p>Let&#39;s create a vector of tracers to represent our input and evaluate our function with it:</p><pre><code class="language-julia hljs">f(x) = x[1] + x[2]*x[3] * sign(x[4])

xtracer = [
    MyGradientTracer(Set(1)),
    MyGradientTracer(Set(2)),
    MyGradientTracer(Set(3)),
    MyGradientTracer(Set(4)),
]

ytracer = f(xtracer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MyGradientTracer(Set(Any[2, 3, 1]))</code></pre><p>Compared to this toy implementation, SCT adds some utilities to automatically create <code>xtracer</code> and parse the output <code>ytracer</code> into a sparse matrix, which we will omit here.</p><p><a href="../../user/api/#SparseConnectivityTracer.TracerSparsityDetector"><code>jacobian_sparsity(f, x, TracerSparsityDetector())</code></a> calls these three steps of (1) tracer creation, (2) function evaluation and (3) output parsing in sequence:</p><pre><code class="language-julia hljs">using SparseConnectivityTracer

x = rand(4)
jacobian_sparsity(f, x, TracerSparsityDetector())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 3 stored entries:
 1  1  1  ⋅</code></pre><h2 id="Tracing-Jacobians"><a class="docs-heading-anchor" href="#Tracing-Jacobians">Tracing Jacobians</a><a id="Tracing-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Tracing-Jacobians" title="Permalink"></a></h2><p>Our toy implementation above doesn&#39;t just work on scalar functions, but also on vector valued functions:</p><pre><code class="language-julia hljs">g(x) = [x[1], x[2]*x[3], x[1]+x[4]]
g(xtracer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Main.MyGradientTracer}:
 Main.MyGradientTracer(Set([1]))
 Main.MyGradientTracer(Set([2, 3]))
 Main.MyGradientTracer(Set([4, 1]))</code></pre><p>By stacking individual <code>MyGradientTracer</code>s row-wise, we obtain the sparsity pattern of the Jacobian of <span>$g$</span></p><p class="math-container">\[J_g(\mathbf{x})=
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; x_3 &amp; x_2 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix} \quad .\]</p><p>We obtain the same result using SCT&#39;s <code>jacobian_sparsity</code>:</p><pre><code class="language-julia hljs">jacobian_sparsity(g, x, TracerSparsityDetector())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×4 SparseArrays.SparseMatrixCSC{Bool, Int64} with 5 stored entries:
 1  ⋅  ⋅  ⋅
 ⋅  1  1  ⋅
 1  ⋅  ⋅  1</code></pre><h2 id="Tracing-Hessians"><a class="docs-heading-anchor" href="#Tracing-Hessians">Tracing Hessians</a><a id="Tracing-Hessians-1"></a><a class="docs-heading-anchor-permalink" href="#Tracing-Hessians" title="Permalink"></a></h2><p>In the sections above, we outlined how to implement our own <a href="../api/#SparseConnectivityTracer.GradientTracer"><code>GradientTracer</code></a> from scratch. <a href="../api/#SparseConnectivityTracer.HessianTracer"><code>HessianTracer</code></a> use the same operator overloading approach but are a bit more involved as they contain two index sets:  one for the gradient pattern and one for the Hessian pattern.  These sets are updated based on whether the first- and second-order derivatives of an operator are zero or not.</p><div class="admonition is-success"><header class="admonition-header">To be published</header><div class="admonition-body"><p>Look forward to our upcoming publication of SparseConnectivityTracer,  where we will go into more detail on the implementation of <code>HessianTracer</code>!</p></div></div><script type="module">import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
mermaid.initialize({
    startOnLoad: true,
    theme: "neutral"
});
</script><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><span>$\frac{\partial x_i}{\partial x_j} \neq 0$</span> only holds for <span>$i=j$</span></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../user/api/">« API Reference</a><a class="docs-footer-nextpage" href="../adding_overloads/">Adding Overloads »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Wednesday 2 October 2024 12:21">Wednesday 2 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
